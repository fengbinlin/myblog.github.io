<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>图方法的python实现 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="图方法的python实现无向图API   12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#实现的功能： # Graph(n)创建一个含有n个节点的邻接表  # Graph.getNumberOfEdge 返回边数# Graph.getNumbe">
<meta property="og:type" content="article">
<meta property="og:title" content="图方法的python实现">
<meta property="og:url" content="https://fengbinlin.github.io/myblog.github.io/2022/02/03/%E5%9B%BE%E6%96%B9%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="图方法的python实现无向图API   12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#实现的功能： # Graph(n)创建一个含有n个节点的邻接表  # Graph.getNumberOfEdge 返回边数# Graph.getNumbe">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-02-03T00:33:32.000Z">
<meta property="article:modified_time" content="2022-02-04T18:40:10.362Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/myblog.github.io/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/myblog.github.io/css/style.css">

<meta name="generator" content="Hexo 5.4.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/myblog.github.io/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/myblog.github.io/">Home</a>
        
          <a class="main-nav-link" href="/myblog.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/myblog.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://fengbinlin.github.io/myblog.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-图方法的python实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/myblog.github.io/2022/02/03/%E5%9B%BE%E6%96%B9%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0/" class="article-date">
  <time datetime="2022-02-03T00:33:32.000Z" itemprop="datePublished">2022-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      图方法的python实现
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>图方法的python实现<br>无向图API  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实现的功能： </span></span><br><span class="line"><span class="comment"># Graph(n)创建一个含有n个节点的邻接表  </span></span><br><span class="line"><span class="comment"># Graph.getNumberOfEdge 返回边数</span></span><br><span class="line"><span class="comment"># Graph.getNumberOfVertex 返回顶点数</span></span><br><span class="line"><span class="comment"># Graph.addEdge(v,w)  添加连接v和w的边  </span></span><br><span class="line"><span class="comment"># Graph.print_graph打印邻接表</span></span><br><span class="line"><span class="comment"># Graph.adj(v) 返回与v相邻的顶点列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#无向图API,邻接表表示这里采用list嵌套list实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n</span>):</span>    <span class="comment">#输入n，初始化长度为n的邻接表</span></span><br><span class="line">        self.n = n <span class="comment"># number of vertex</span></span><br><span class="line">        self.m = <span class="number">0</span> <span class="comment">#number of edge</span></span><br><span class="line">        self.matrix = [[] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment">#初始化邻接表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNumberOfEdge</span>(<span class="params">self</span>):</span>     <span class="comment">#返回边数</span></span><br><span class="line">        <span class="keyword">return</span> self.m</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNumberOfVertex</span>(<span class="params">self</span>):</span>    <span class="comment">#返回顶点数</span></span><br><span class="line">        <span class="keyword">return</span> self.n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addEdge</span>(<span class="params">self,v,w</span>):</span>    <span class="comment">#添加边</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= v &lt;= self.n <span class="keyword">and</span> <span class="number">0</span> &lt;= w &lt;= self.n:</span><br><span class="line">            self.matrix[v].append(w)</span><br><span class="line">            self.matrix[w].append(v)</span><br><span class="line">        self.m=self.m+<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_graph</span>(<span class="params">self</span>):</span>  <span class="comment">#打印邻接表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line"></span><br><span class="line">            nei=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.matrix[i])):</span><br><span class="line">                nei.append(self.matrix[i][j])</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;和这些点连接&quot;</span>+<span class="built_in">str</span>(nei))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adj</span>(<span class="params">self,v</span>):</span>   <span class="comment">#返回相邻顶点</span></span><br><span class="line">        <span class="keyword">return</span> self.matrix[v]</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line">g=Graph(<span class="number">6</span>)</span><br><span class="line">g.addEdge(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">g.addEdge(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">g.addEdge(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">g.addEdge(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;顶点个数&quot;</span>+<span class="built_in">str</span>(g.getNumberOfEdge()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;边个数&quot;</span>+<span class="built_in">str</span>(g.getNumberOfVertex()))</span><br><span class="line">g.print_graph()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;索引为3的顶点的相邻顶点&quot;</span>+<span class="built_in">str</span>(g.adj(<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># 顶点个数4</span></span><br><span class="line"><span class="comment"># 边个数6</span></span><br><span class="line"><span class="comment"># 0和这些点连接[]</span></span><br><span class="line"><span class="comment"># 1和这些点连接[2]</span></span><br><span class="line"><span class="comment"># 2和这些点连接[3, 1]</span></span><br><span class="line"><span class="comment"># 3和这些点连接[2, 4]</span></span><br><span class="line"><span class="comment"># 4和这些点连接[5, 3]</span></span><br><span class="line"><span class="comment"># 5和这些点连接[4]</span></span><br><span class="line"><span class="comment"># 索引为3的顶点的相邻顶点[2, 4]</span></span><br></pre></td></tr></table></figure>
<p>深度优先搜索</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实现的功能：</span></span><br><span class="line"><span class="comment"># DeptFirstSearch(G,s)    输入图像和搜素的起点</span></span><br><span class="line"><span class="comment"># DeptFirstSearch.boolen_mark(w)  查询w点是否被标记</span></span><br><span class="line"><span class="comment"># DeptFirstSearch.count() 返回遍历的点数</span></span><br><span class="line"><span class="comment">#深度优先搜索</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepthFirstSearch</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G,s</span>):</span></span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]   <span class="comment">#创建标记表，搜索过的点表位True，否则为False</span></span><br><span class="line">        self.count_=<span class="number">0</span>   <span class="comment">#节点个数</span></span><br><span class="line">        self.dfs(G,s)   <span class="comment">#调用深度优先搜索</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,G,v</span>):</span></span><br><span class="line">        self.marked[v]=<span class="literal">True</span></span><br><span class="line">        self.count_=self.count_+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G.adj(v):  <span class="comment">#对图G中点v的相邻点执行相同操作</span></span><br><span class="line">            <span class="keyword">if</span>(self.marked[w]!=<span class="literal">True</span>):</span><br><span class="line">                self.dfs(G,w)   <span class="comment">#递归。</span></span><br><span class="line"><span class="comment">#这里详细讲一下，会一直递归下去，递归一次就会深入一层，没有为标记的点时就返回上一层，到下一个相邻的节点继续递归。因为是先深入，没有路了才返到上一个路口，所以叫深度优先。</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">boolen_marked</span>(<span class="params">self,w</span>):</span>  <span class="comment">#查询某点是否被标记</span></span><br><span class="line">        <span class="keyword">return</span> self.marked[w]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self</span>):</span>    <span class="comment">#返回搜索的点数</span></span><br><span class="line">        <span class="keyword">return</span> self.count_</span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line"><span class="comment">#g为上一个图算法的g</span></span><br><span class="line">D=DepthFirstSearch(g,<span class="number">2</span>)     <span class="comment">#输入该图和起点</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;编号为3的点搜索情况&quot;</span>+<span class="built_in">str</span>(D.boolen_marked(<span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;搜索到的点数&quot;</span>+<span class="built_in">str</span>(D.count()))</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 编号为3的点搜索情况True</span></span><br><span class="line"><span class="comment"># 搜索到的点数5</span></span><br></pre></td></tr></table></figure>
<p>广度优先算法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#广度优先搜索</span></span><br><span class="line"><span class="comment">#实现的功能</span></span><br><span class="line"><span class="comment"># BreadthFirstPaths(G,s)  输入一幅图和搜素的起点初始化</span></span><br><span class="line"><span class="comment"># BreadthFirstPaths.hasPathTo(v)  检测v和起点是否相通</span></span><br><span class="line"><span class="comment"># BreadthFirstPaths.pathTo(v) 获得起点到v的路径</span></span><br><span class="line"><span class="keyword">import</span> queue    <span class="comment">#导入队列模块</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment">#导入栈模块</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G,s</span>):</span> <span class="comment">#初始化</span></span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]   <span class="comment">#标记列表</span></span><br><span class="line">        self.edgeTo=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]   <span class="comment">#路径记录列表，记录通往改点的上一点即可</span></span><br><span class="line">        self.s=s    <span class="comment">#记录起点</span></span><br><span class="line">        self.path = deque() <span class="comment">#创建队列，后面要用</span></span><br><span class="line">        self.bfs(G,s)   <span class="comment">#调用函数实现广度优先</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span>(<span class="params">self,G,s</span>):</span>  <span class="comment">#广度优先函数</span></span><br><span class="line">        queue_=queue.Queue()    <span class="comment">#创建队列</span></span><br><span class="line">        self.marked[s]=<span class="literal">True</span> <span class="comment">#起点设为已标记</span></span><br><span class="line">        queue_.put(s)   <span class="comment">#将起点加入队列</span></span><br><span class="line">        <span class="keyword">while</span>(queue_.empty()!=<span class="literal">True</span>):    <span class="comment">#当队列不为空时</span></span><br><span class="line">            v=queue_.get()  <span class="comment">#将队列最后一个元素取出</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> G.adj(v) : <span class="comment">#遍历v的相邻节点</span></span><br><span class="line">                <span class="keyword">if</span>(self.marked[w]!=<span class="literal">True</span>):   <span class="comment">#如果改点没有标记</span></span><br><span class="line">                    self.edgeTo[w]=v    <span class="comment">#改点上一个连接点设为v</span></span><br><span class="line">                    self.marked[w]=<span class="literal">True</span>     <span class="comment">#设为已标记</span></span><br><span class="line">                    queue_.put(w)   <span class="comment">#将它加入队列</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathTo</span>(<span class="params">self,v</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.marked[v]   <span class="comment">#返回该点是否被标记</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathTo</span>(<span class="params">self,v</span>):</span> <span class="comment">#利用栈记录递归从队列中得到的路径</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(self.hasPathTo(v)!=<span class="literal">True</span>):<span class="comment">#如果该点连通，返回空值</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.path.append(v)  <span class="comment"># 向栈中添加终点</span></span><br><span class="line">        self.getpath(v) <span class="comment">#带入终点，递归，获得路径</span></span><br><span class="line">        <span class="keyword">return</span> self.path</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getpath</span>(<span class="params">self,x</span>):</span>    <span class="comment">#获得路径的算法</span></span><br><span class="line">        <span class="keyword">if</span> x!=self.s:   <span class="comment">#如果和起点不相同</span></span><br><span class="line">            x=self.edgeTo[x]    <span class="comment">#得到x点的上一点并赋值于x</span></span><br><span class="line">            self.path.append(x) <span class="comment">#将x添加如栈</span></span><br><span class="line">            self.getpath(x) <span class="comment">#再次递归</span></span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line">B=BreadthFirstPaths(g,<span class="number">1</span>)    <span class="comment">#输入图g和起点1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;起到到3连通吗&quot;</span>+<span class="built_in">str</span>(B.hasPathTo(<span class="number">3</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;从起点到5的路径为&quot;</span>+<span class="built_in">str</span>(B.pathTo(<span class="number">5</span>)))</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="comment"># 起到到3连通吗True</span></span><br><span class="line"><span class="comment"># 从起点到5的路径为deque([5, 4, 3, 2, 1])</span></span><br></pre></td></tr></table></figure>

<p>获得连通分量的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#连通分量指的是，一副图里面有多少个不相互连通的部分</span></span><br><span class="line"><span class="comment">#实现的功能：</span></span><br><span class="line"><span class="comment"># CC(G)   输入一副图</span></span><br><span class="line"><span class="comment"># CC.bool_connected(v,w)  v和w是否连通，返回值为布尔类型</span></span><br><span class="line"><span class="comment"># CC.get_id(v)    得到v点的连通分量标号</span></span><br><span class="line"><span class="comment"># CC.get_count()  得到改图的连通分量</span></span><br><span class="line"><span class="comment">#连通分量（使用深度学习优先搜索找出图中所有连通分量）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G</span>):</span></span><br><span class="line">        self.count=<span class="number">0</span>    <span class="comment">#用于计算连通分量的数量</span></span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]   <span class="comment">#用来记录点是否标记</span></span><br><span class="line">        self.<span class="built_in">id</span>=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]   <span class="comment">#用来记录各个点的连通分量代号</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex()):  <span class="comment">#对图的每个点遍历</span></span><br><span class="line">            <span class="keyword">if</span>(self.marked[s]!=<span class="literal">True</span>):  </span><br><span class="line">                <span class="comment">#若没有标记就使用深度优先搜索，然后给各个标记上。这</span></span><br><span class="line">                <span class="comment"># 个部分有意思，以为每个点都要来一次，其实一次深度优先，许多点都会标记上，不会再次深度优先的</span></span><br><span class="line">                self.dfs(G,s)</span><br><span class="line">                self.count=self.count+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, G, v</span>):</span>    <span class="comment">#深度优先算法，前面讲过了，不在记录了</span></span><br><span class="line">        self.marked[v] = <span class="literal">True</span></span><br><span class="line">        self.<span class="built_in">id</span>[v]=self.count</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G.adj(v):  <span class="comment"># 对图G中点v的相邻点执行相同操作</span></span><br><span class="line">            <span class="keyword">if</span> (self.marked[w] != <span class="literal">True</span>):</span><br><span class="line">                self.dfs(G, w)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bool_connected</span>(<span class="params">self,v,w</span>):</span>   <span class="comment">#返回是否连通，是一个布尔值。如果处于同一个连通分量就是连通的。</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">id</span>[v]==self.<span class="built_in">id</span>[w]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_id</span>(<span class="params">self,v</span>):</span> <span class="comment">#得到某点的连通分量</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">id</span>[v]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_count</span>(<span class="params">self</span>):</span>    <span class="comment">#得到连通分量的个数</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line">c=CC(g)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;连通分量的数量是&quot;</span>+<span class="built_in">str</span>(c.get_count()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;点0和5相通吗&quot;</span>+<span class="built_in">str</span>(c.bool_connected(<span class="number">0</span>,<span class="number">5</span>)))</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 连通分量的数量是1</span></span><br><span class="line"><span class="comment"># 点0和5相同吗True</span></span><br></pre></td></tr></table></figure>

<p>是否成环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解决成环问题,即回答一幅图是否是无环图</span></span><br><span class="line"><span class="comment">#实现的功能</span></span><br><span class="line"><span class="comment"># Cycle(G)    传入一幅图</span></span><br><span class="line"><span class="comment"># Cycle.bool_hasCycle 返回是否成环</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cycle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G</span>):</span></span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]</span><br><span class="line">        self.hasCycle=<span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex()):  <span class="comment"># 对图的每个点遍历</span></span><br><span class="line">            <span class="keyword">if</span> (self.marked[s] != <span class="literal">True</span>):</span><br><span class="line">                <span class="comment"># 若没有标记就使用深度优先搜索，然后给各个标记上。这</span></span><br><span class="line">                <span class="comment"># 个部分有意思，以为每个点都要来一次，其实一次深度优先，许多点都会标记上，不会再次深度优先的</span></span><br><span class="line">                self.dfs(G, s,s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, G, v,u</span>):</span>  <span class="comment"># 深度优先算法，前面讲过了，不在记录了</span></span><br><span class="line">        self.marked[v] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G.adj(v):  <span class="comment"># 对图G中点v的相邻点执行相同操作</span></span><br><span class="line">            <span class="keyword">if</span> (self.marked[w] != <span class="literal">True</span>):</span><br><span class="line">                self.dfs(G, w,v)</span><br><span class="line">            <span class="keyword">elif</span> w!=u:  <span class="comment">#这个算法检测是否成环的原理就是多传导一个参数来记录前一个点，</span></span><br><span class="line">                        <span class="comment"># 再加一个判断条件，如果深入的时候，碰到了标记过的点，却又不是前一个点，那么他就成环了</span></span><br><span class="line">                self.hasCycle=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bool_hasCycle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.hasCycle</span><br><span class="line"><span class="comment">#测试代码，因为前面的代码都是没有成环的，所以我们重新创建一个有环的图</span></span><br><span class="line">g=Graph(<span class="number">6</span>)</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">g.addEdge(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">g.addEdge(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">g.addEdge(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">g.addEdge(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">g.addEdge(<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line">cy=Cycle(g)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;成环吗&quot;</span>+<span class="built_in">str</span>(cy.bool_hasCycle()))</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 成环吗True</span></span><br></pre></td></tr></table></figure>

<p>是二分图吗?双色问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#双色问题</span></span><br><span class="line"><span class="comment">#实现的功能</span></span><br><span class="line"><span class="comment"># TwoColor(G) 输入一幅图</span></span><br><span class="line"><span class="comment"># TwoColor.bool_isBipartite() 返回是否满足双色问题的布尔值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoColor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G</span>):</span></span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]</span><br><span class="line">        self.color=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]</span><br><span class="line">        self.isTwoColorable=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex()):  <span class="comment"># 对图的每个点遍历</span></span><br><span class="line">            <span class="keyword">if</span> (self.marked[s] != <span class="literal">True</span>):</span><br><span class="line">                <span class="comment"># 若没有标记就使用深度优先搜索，然后给各个标记上。这</span></span><br><span class="line">                <span class="comment"># 个部分有意思，以为每个点都要来一次，其实一次深度优先，许多点都会标记上，不会再次深度优先的</span></span><br><span class="line">                self.dfs(G, s,)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, G, v</span>):</span>  <span class="comment"># 深度优先算法，前面讲过了，不在记录了</span></span><br><span class="line">        self.marked[v] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G.adj(v):  <span class="comment"># 对图G中点v的相邻点执行相同操作</span></span><br><span class="line">            <span class="keyword">if</span> (self.marked[w] != <span class="literal">True</span>):</span><br><span class="line">                self.color[w]=<span class="keyword">not</span> self.color[v]</span><br><span class="line">                self.dfs(G, w)</span><br><span class="line">            <span class="keyword">elif</span> self.color[w]==self.color[v]:</span><br><span class="line">                self.isTwoColorable=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bool_isBipartite</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.isTwoColorable</span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line">tc=TwoColor(g)  <span class="comment">#使用的是上一个算法有环的那个图</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;双色问题满足吗&quot;</span>+<span class="built_in">str</span>(tc.bool_isBipartite()))</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment">#双色问题满足吗False</span></span><br></pre></td></tr></table></figure>
<p>有向图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有向图</span></span><br><span class="line"><span class="comment">#和无向图类似，多了个reverse，且只添加了一次边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Digraph</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,n</span>):</span>    <span class="comment">#输入n，初始化长度为n的邻接表</span></span><br><span class="line">        self.n = n <span class="comment"># number of vertex</span></span><br><span class="line">        self.m = <span class="number">0</span> <span class="comment">#number of edge</span></span><br><span class="line">        self.matrix = [[] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="comment">#初始化邻接表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNumberOfEdge</span>(<span class="params">self</span>):</span>     <span class="comment">#返回边数</span></span><br><span class="line">        <span class="keyword">return</span> self.m</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNumberOfVertex</span>(<span class="params">self</span>):</span>    <span class="comment">#返回顶点数</span></span><br><span class="line">        <span class="keyword">return</span> self.n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addEdge</span>(<span class="params">self,v,w</span>):</span>    <span class="comment">#添加边</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= v &lt;= self.n <span class="keyword">and</span> <span class="number">0</span> &lt;= w &lt;= self.n:</span><br><span class="line">            self.matrix[v].append(w)</span><br><span class="line">        self.m=self.m+<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_graph</span>(<span class="params">self</span>):</span>  <span class="comment">#打印邻接表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n):</span><br><span class="line"></span><br><span class="line">            nei=[]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(self.matrix[i])):</span><br><span class="line">                nei.append(self.matrix[i][j])</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">str</span>(i) + <span class="string">&quot;和这些点连接&quot;</span>+<span class="built_in">str</span>(nei))</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adj</span>(<span class="params">self,v</span>):</span>   <span class="comment">#返回相邻顶点</span></span><br><span class="line">        <span class="keyword">return</span> self.matrix[v]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self</span>):</span></span><br><span class="line">        R=Digraph(self.n)</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span>  <span class="built_in">range</span>(self.n):</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> self.adj(v):</span><br><span class="line">                R.addEdge(w,v)</span><br><span class="line">        <span class="keyword">return</span> R</span><br></pre></td></tr></table></figure>
<p>有向图的可达性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有向图的可达性</span></span><br><span class="line"><span class="comment">#实现的功能</span></span><br><span class="line"><span class="comment"># DirectedDFS(G,s)    输入图和搜索起点，初始化算法</span></span><br><span class="line"><span class="comment"># DirectedDFS(G,s).bool_marked(v)    判断v和s是否连通，返回值为布尔类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectedDFS</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G,s:<span class="built_in">int</span></span>):</span></span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isinstance</span>(s, <span class="built_in">list</span>)):</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> s:</span><br><span class="line">                <span class="keyword">if</span> (self.marked[x] != <span class="literal">True</span>):</span><br><span class="line">                    self.dfs(G, x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dfs(G, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,G,v</span>):</span></span><br><span class="line">        self.marked[v]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G.adj(v):</span><br><span class="line">            <span class="keyword">if</span> self.marked[w]!=<span class="literal">True</span>:</span><br><span class="line">                self.dfs(G,w)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bool_marked</span>(<span class="params">self,v</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.marked[v]</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line"><span class="comment">#创建一副有向图</span></span><br><span class="line">D=Digraph(<span class="number">5</span>)</span><br><span class="line">D.addEdge(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">D.addEdge(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">D.addEdge(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">D.addEdge(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">DD=DirectedDFS(D,<span class="number">0</span>) <span class="comment">#从起点0开始搜索，标记所有与他相邻的顶点</span></span><br><span class="line"><span class="built_in">print</span>(DD.marked)    <span class="comment">#打印标记情况</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0和2是否连通&quot;</span>+<span class="built_in">str</span>(DD.bool_marked(<span class="number">2</span>)))</span><br><span class="line">DD_=DirectedDFS(D,[<span class="number">2</span>,<span class="number">0</span>])    <span class="comment">#从起点2,0开始搜索，标记所有与他们相邻的顶点</span></span><br><span class="line"><span class="built_in">print</span>(DD_.marked)   <span class="comment">#打印标记情况</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0,2和2是否连通&quot;</span>+<span class="built_in">str</span>(DD_.bool_marked(<span class="number">2</span>)))</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># [True, True, False, True, True]</span></span><br><span class="line"><span class="comment"># 0和2是否连通False</span></span><br><span class="line"><span class="comment"># [True, True, True, True, True]</span></span><br><span class="line"><span class="comment"># 0,2和2是否连通True</span></span><br></pre></td></tr></table></figure>

<p>寻找有向环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#寻找有向环</span></span><br><span class="line"><span class="comment">#实现的功能</span></span><br><span class="line"><span class="comment"># DirectedCycle(D)     带入有向图实例化对象</span></span><br><span class="line"><span class="comment"># DirectedCycle.getCycle()   得到环，返回的是一个栈类型（双向队列）</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque   <span class="comment">#导入栈模块</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G</span>):</span></span><br><span class="line">        self.cycle = deque()</span><br><span class="line">        self.onStack=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]</span><br><span class="line">        self.edgeTo=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]</span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]</span><br><span class="line">        self.Stack=deque()</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex()):</span><br><span class="line">            <span class="keyword">if</span> self.marked[v]!=<span class="literal">True</span>:</span><br><span class="line">                self.dfs(G,v)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,G,v</span>):</span></span><br><span class="line">        self.onStack[v]=<span class="literal">True</span></span><br><span class="line">        self.marked[v]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G.adj(v):</span><br><span class="line">            <span class="keyword">if</span> self.cycle:  <span class="comment">#如果环存在，直接返回</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> self.marked[w]!=<span class="literal">True</span>:  <span class="comment">#如果遇到没有标记的点，将它标记</span></span><br><span class="line">                self.edgeTo[w]=v</span><br><span class="line">                self.dfs(G,w)</span><br><span class="line">            <span class="keyword">elif</span> self.onStack[w]==<span class="literal">True</span>: <span class="comment">#这里这个设计很妙，采用了OnStack来记录沿途，先对搜索过的点标记为True，如果深度搜索没有路了，返回上一层又改回FALSE。</span></span><br><span class="line">                <span class="comment">#所以没有环的话，遍历的过程中是不会碰到下一个目标点的onStack为True的情况，如果碰到，说明程序返回不了上一层，就成环了。</span></span><br><span class="line">                self.addCycle(v,w)</span><br><span class="line">                self.cycle.append(v)</span><br><span class="line">        self.onStack[v]=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addCycle</span>(<span class="params">self,x,w</span>):</span>    <span class="comment">#获得路径的算法</span></span><br><span class="line">        <span class="keyword">if</span> x!=w:   <span class="comment">#如果和起点不相同</span></span><br><span class="line">            x=self.edgeTo[x]    <span class="comment">#得到x点的上一点并赋值于x</span></span><br><span class="line">            self.cycle.append(x) <span class="comment">#将x添加如栈</span></span><br><span class="line">            self.addCycle(x,w) <span class="comment">#再次递归</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getCycle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.cycle</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line"><span class="comment">#创建一副有向图</span></span><br><span class="line">D=Digraph(<span class="number">5</span>)</span><br><span class="line">D.addEdge(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">D.addEdge(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">D.addEdge(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">D.addEdge(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">D.addEdge(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">DS=DirectedCycle(D) <span class="comment">#实例化类</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;环:&quot;</span>+<span class="built_in">str</span>(DS.getCycle()))    <span class="comment">#得到环</span></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 环:deque([4, 1, 2])</span></span><br></pre></td></tr></table></figure>

<p>基于深度优先的顶点排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实现的功能</span></span><br><span class="line"><span class="comment">#在不同的时刻记录标记的点，存入队列和栈</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G</span>):</span></span><br><span class="line">        self.pre=queue.Queue()</span><br><span class="line">        self.post=queue.Queue()</span><br><span class="line">        self.reversePost=deque()</span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex()):</span><br><span class="line">            <span class="keyword">if</span> self.marked[v]!=<span class="literal">True</span>:</span><br><span class="line">                self.dfs(G,v)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self,G,v</span>):</span></span><br><span class="line">        self.pre.put(v)</span><br><span class="line">        self.marked[v]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G.adj(v):</span><br><span class="line">            <span class="keyword">if</span>(self.marked[w]!=<span class="literal">True</span>):</span><br><span class="line">                self.dfs(G,w)</span><br><span class="line">        self.post.put(v)</span><br><span class="line">        self.reversePost.append(v)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pre</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.pre</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_post</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.post</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_reversePost</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.reversePost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line">D=Digraph(<span class="number">5</span>)</span><br><span class="line">D.addEdge(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">D.addEdge(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">D.addEdge(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">D.addEdge(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">DO=DepthFirstOrder(D)</span><br><span class="line"></span><br><span class="line"><span class="comment">#输出pre 前序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;前序&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> DO.get_pre().empty()!=<span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(DO.get_pre().get())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------------------------------------&quot;</span>)</span><br><span class="line"><span class="comment">#输出post 后序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;后序&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> DO.get_post().empty()!=<span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(DO.get_post().get())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;---------------------------------------------&quot;</span>)</span><br><span class="line"><span class="comment">#输出reversePost  栈</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;栈&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> DO.get_reversePost():</span><br><span class="line">    <span class="built_in">print</span>(DO.get_reversePost().pop())</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 前序</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># ---------------------------------------------</span></span><br><span class="line"><span class="comment"># 后序</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># ---------------------------------------------</span></span><br><span class="line"><span class="comment"># 栈</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>
<p>拓扑排列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topological</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G</span>):</span></span><br><span class="line">        self.order=[]</span><br><span class="line">        self.cyclefinder=DirectedCycle(G)</span><br><span class="line">        <span class="keyword">if</span>(self.cyclefinder.hasCycle()):</span><br><span class="line">            self.dfs=DepthFirstOrder(G)</span><br><span class="line">            self.order=self.dfs.reversePost()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_order</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.order</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bool_isDAG</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.order!=<span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>有向图的强连通性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#连通分量（使用深度学习优先搜索找出图中所有连通分量）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KosarajuSCC</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G</span>):</span></span><br><span class="line">        self.count=<span class="number">0</span>    <span class="comment">#用于计算连通分量的数量</span></span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]   <span class="comment">#用来记录点是否标记</span></span><br><span class="line">        self.<span class="built_in">id</span>=[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.getNumberOfVertex())]   <span class="comment">#用来记录各个点的连通分量代号</span></span><br><span class="line">        self.order=DepthFirstOrder(G.reverse())</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">list</span>(self.order.get_reversePost()):  <span class="comment">#对图的每个点遍历</span></span><br><span class="line">            <span class="keyword">if</span>(self.marked[s]!=<span class="literal">True</span>):</span><br><span class="line">                <span class="comment">#若没有标记就使用深度优先搜索，然后给各个标记上。这</span></span><br><span class="line">                <span class="comment"># 个部分有意思，以为每个点都要来一次，其实一次深度优先，许多点都会标记上，不会再次深度优先的</span></span><br><span class="line">                self.dfs(G,s)</span><br><span class="line">                self.count=self.count+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">self, G, v</span>):</span>    <span class="comment">#深度优先算法，前面讲过了，不在记录了</span></span><br><span class="line">        self.marked[v] = <span class="literal">True</span></span><br><span class="line">        self.<span class="built_in">id</span>[v]=self.count</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> G.adj(v):  <span class="comment"># 对图G中点v的相邻点执行相同操作</span></span><br><span class="line">            <span class="keyword">if</span> (self.marked[w] != <span class="literal">True</span>):</span><br><span class="line">                self.dfs(G, w)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bool_stronglyconnected</span>(<span class="params">self,v,w</span>):</span>   <span class="comment">#返回是否连通，是一个布尔值。如果处于同一个连通分量就是连通的。</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">id</span>[v]==self.<span class="built_in">id</span>[w]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_id</span>(<span class="params">self,v</span>):</span> <span class="comment">#得到某点的连通分量</span></span><br><span class="line">        <span class="keyword">return</span> self.<span class="built_in">id</span>[v]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_count</span>(<span class="params">self</span>):</span>    <span class="comment">#得到连通分量的个数</span></span><br><span class="line">        <span class="keyword">return</span> self.count</span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line">D=Digraph(<span class="number">5</span>)</span><br><span class="line">D.addEdge(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">D.addEdge(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">D.addEdge(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">D.addEdge(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">D.addEdge(<span class="number">4</span>,<span class="number">1</span>)</span><br><span class="line">KSCC=KosarajuSCC(D)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;连通分量的数量是&quot;</span>+<span class="built_in">str</span>(KSCC.get_count()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;点0和2强相通吗&quot;</span>+<span class="built_in">str</span>(KSCC.bool_stronglyconnected(<span class="number">0</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;点1和4强相通吗&quot;</span>+<span class="built_in">str</span>(KSCC.bool_stronglyconnected(<span class="number">1</span>,<span class="number">4</span>)))</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 连通分量的数量是2</span></span><br><span class="line"><span class="comment"># 点0和2强相通吗False</span></span><br><span class="line"><span class="comment"># 点1和4强相通吗True</span></span><br></pre></td></tr></table></figure>
<p>在原书中有一段再谈可达性，我不太清楚是什么意思，和前面写过的DirectedDFS差不多，不重点讨论了。</p>
<p>带权重的边的数据类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现的功能</span></span><br><span class="line"><span class="comment"># Edge(v,w,weight)    设置边的起点、终点、权重</span></span><br><span class="line"><span class="comment"># Edge.get_weight() 返回边的权重</span></span><br><span class="line"><span class="comment"># Edge.get_either() 返回边的起点</span></span><br><span class="line"><span class="comment"># Edge.order(vertex)  返回另一个顶点</span></span><br><span class="line"><span class="comment"># Edge.compareTo(that)    和另一条边比较</span></span><br><span class="line"><span class="comment"># Edge.toString() 打印边</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,v,w,weight</span>):</span>  <span class="comment">#设置边的起点、终点、权重</span></span><br><span class="line">        self.v=v</span><br><span class="line">        self.w=w</span><br><span class="line">        self.weight=weight</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_weight</span>(<span class="params">self</span>):</span>   <span class="comment">#返回边的权重</span></span><br><span class="line">        <span class="keyword">return</span> self.weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_either</span>(<span class="params">self</span>):</span>   <span class="comment">#返回边的起点</span></span><br><span class="line">        <span class="keyword">return</span> self.v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">order</span>(<span class="params">self,vertex</span>):</span> <span class="comment">#返回另一个顶点</span></span><br><span class="line">        <span class="keyword">if</span> vertex==self.v:</span><br><span class="line">            <span class="keyword">return</span> self.w</span><br><span class="line">        <span class="keyword">if</span> vertex==self.w:</span><br><span class="line">            <span class="keyword">return</span> self.v</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compareTo</span>(<span class="params">self,that</span>):</span>   <span class="comment">#和另一条边比较</span></span><br><span class="line">        <span class="keyword">if</span> self.weight&lt;that.weight:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.weight&gt;that.weight:</span><br><span class="line">            <span class="keyword">return</span> +<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">toString</span>(<span class="params">self</span>):</span> <span class="comment">#打印边</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">str</span>.<span class="built_in">format</span>(<span class="string">&quot;%d-%d %.2f&quot;</span>%(self.v,self.w,self.weight))</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line">Eg=Edge(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">Eg_=Edge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line"><span class="built_in">print</span>(Eg.get_weight())  <span class="comment">#返回权重</span></span><br><span class="line"><span class="built_in">print</span>(Eg.order(<span class="number">3</span>))  <span class="comment">#返回和3相连的另一点</span></span><br><span class="line"><span class="built_in">print</span>(Eg.get_either())  <span class="comment">#返回边的出发点</span></span><br><span class="line"><span class="built_in">print</span>(Eg_.get_weight()) <span class="comment">#返回权重</span></span><br><span class="line"><span class="built_in">print</span>(Eg_.order(<span class="number">4</span>)) <span class="comment">#返回和4相连的另一点</span></span><br><span class="line"><span class="built_in">print</span>(Eg_.get_either()) <span class="comment">#返回边的出发点</span></span><br><span class="line"><span class="built_in">print</span>(Eg.compareTo(Eg_))    <span class="comment">#返回边的权重比较结果</span></span><br><span class="line"><span class="built_in">print</span>(Eg.toString())    <span class="comment">#打印边</span></span><br><span class="line"><span class="built_in">print</span>(Eg_.toString())   <span class="comment">#打印边</span></span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># -1</span></span><br><span class="line"><span class="comment"># 2-3 5.00</span></span><br><span class="line"><span class="comment"># 1-4 7.00</span></span><br></pre></td></tr></table></figure>

<p>加权无向图的数据类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#功能注释在方法旁边了，接下来都这样子写。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedGraph</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,v</span>):</span>   <span class="comment">#初始化</span></span><br><span class="line">        self.v=v</span><br><span class="line">        self.e=<span class="number">0</span></span><br><span class="line">        self.adj=[[]<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(v)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addEdge</span>(<span class="params">self,e</span>):</span>    <span class="comment">#添加边</span></span><br><span class="line">        v=e.get_either()</span><br><span class="line">        w=e.order(v)</span><br><span class="line">        self.adj[v].append(e)</span><br><span class="line">        self.adj[w].append(e)</span><br><span class="line">        self.e=self.e+<span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">V</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.v</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">E</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.e</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">adj_</span>(<span class="params">self,v</span>):</span>   <span class="comment">#获得所有相邻边</span></span><br><span class="line">        <span class="keyword">return</span> self.adj[v]</span><br><span class="line"><span class="comment">#创建一系列有权边</span></span><br><span class="line">Eg=Edge(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">Eg_=Edge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>)</span><br><span class="line">Eg_2=Edge(<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Eg_3=Edge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#初始化加权无向图并添加边</span></span><br><span class="line">EWG=EdgeWeightedGraph(<span class="number">5</span>)</span><br><span class="line">EWG.addEdge(Eg)</span><br><span class="line">EWG.addEdge(Eg_)</span><br><span class="line">EWG.addEdge(Eg_2)</span><br><span class="line">EWG.addEdge(Eg_3)</span><br><span class="line"><span class="comment">#返回与4点相邻的点的第一个点的起点</span></span><br><span class="line"><span class="built_in">print</span>(EWG.adj_(<span class="number">4</span>)[<span class="number">0</span>].get_either())</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment">#优先队列</span></span><br><span class="line"><span class="comment">#实现的功能，存储边并可以找出权重最小的边</span></span><br><span class="line"><span class="comment"># class MinPQ:</span></span><br><span class="line"><span class="comment">#     def __init__(self):</span></span><br><span class="line"><span class="comment">#         self.PQ=[]</span></span><br><span class="line"><span class="comment">#     def delMin(self):</span></span><br><span class="line"><span class="comment">#         weitht_=[]</span></span><br><span class="line"><span class="comment">#         for i in self.PQ:</span></span><br><span class="line"><span class="comment">#             weitht_.append(i.weight)</span></span><br><span class="line"><span class="comment">#         s=weitht_.index(min(weitht_))</span></span><br><span class="line"><span class="comment">#         return s</span></span><br><span class="line"><span class="comment">#     def find_Min(self):</span></span><br><span class="line"><span class="comment">#     def insert(self,e):</span></span><br><span class="line"><span class="comment">#         self.PQ.append(e)</span></span><br></pre></td></tr></table></figure>
<p>最小生成树Prim算法的延迟实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#实现的功能输入一幅图就可以找到他的最小连通树</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyPrimMST</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G</span>):</span></span><br><span class="line">        self.pq=[]</span><br><span class="line">        self.marked=[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.V())]</span><br><span class="line">        self.mst=queue.Queue()</span><br><span class="line">        self.visit(G,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.pq)!=<span class="number">0</span>:</span><br><span class="line">            e=self.pq[self.getmin(self.pq)]</span><br><span class="line">            <span class="keyword">del</span> self.pq[self.getmin(self.pq)]</span><br><span class="line">            v=e.get_either()</span><br><span class="line">            w=e.order(v)</span><br><span class="line">            <span class="keyword">if</span>(self.marked[v]==<span class="literal">True</span> )<span class="keyword">and</span>( self.marked[w]==<span class="literal">True</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.mst.put(e)</span><br><span class="line">            <span class="keyword">if</span> self.marked[v]!=<span class="literal">True</span>:</span><br><span class="line">                self.visit(G,v)</span><br><span class="line">            <span class="keyword">if</span> self.marked[w]!=<span class="literal">True</span>:</span><br><span class="line">                self.visit(G,w)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span>(<span class="params">self,G,v</span>):</span></span><br><span class="line">        self.marked[v]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> G.adj_(v):</span><br><span class="line">            <span class="keyword">if</span> self.marked[e.order(v)]!=<span class="literal">True</span>:</span><br><span class="line">                self.pq.append(e)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Edges</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.mst</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getmin</span>(<span class="params">self,pq</span>):</span>    <span class="comment">#找到列表pq中的最小元素并返回索引</span></span><br><span class="line">        weitht_=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pq:</span><br><span class="line">            weitht_.append(i.weight)</span><br><span class="line">        s=weitht_.index(<span class="built_in">min</span>(weitht_))</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line"><span class="comment">#测试代码</span></span><br><span class="line">La=LazyPrimMST(EWG)</span><br><span class="line"><span class="keyword">while</span> La.Edges().empty()!=<span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(La.Edges().get().toString())</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 0-1 2.00</span></span><br><span class="line"><span class="comment"># 1-4 7.00</span></span><br><span class="line"><span class="comment"># 4-2 3.00</span></span><br><span class="line"><span class="comment"># 2-3 5.00</span></span><br></pre></td></tr></table></figure>
<p>最小生成树Prim算法的即使实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,G</span>):</span></span><br><span class="line">        self.edgeTo=[Edge(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.V())]</span><br><span class="line">        self.disTo = [<span class="number">0.00</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.V())]</span><br><span class="line">        self.marked = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(G.V())]</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> <span class="built_in">range</span>(G.V()):</span><br><span class="line">            self.disTo[v]=<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        self.pq=[]</span><br><span class="line">        self.disTo[<span class="number">0</span>]=<span class="number">0.0</span></span><br><span class="line">        self.pq.append((<span class="number">0</span>,<span class="number">0.0</span>))</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.pq)!=<span class="number">0</span>:</span><br><span class="line">            s=self.pq[self.getmin(self.pq)][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">del</span> self.pq[self.getmin(self.pq)]</span><br><span class="line">            self.visit(G,s)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getmin</span>(<span class="params">self, pq</span>):</span>  <span class="comment"># 找到列表pq中的最小元素并返回索引</span></span><br><span class="line">        weitht_ = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pq:</span><br><span class="line">            weitht_.append(i[<span class="number">1</span>])</span><br><span class="line">        s = weitht_.index(<span class="built_in">min</span>(weitht_))</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span>(<span class="params">self,G,v</span>):</span></span><br><span class="line">        self.marked[v]=<span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> G.adj_(v):</span><br><span class="line">            w=e.order(v)</span><br><span class="line">            <span class="keyword">if</span> self.marked[w]==<span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> e.weight&lt;self.disTo[w]:</span><br><span class="line">                self.edgeTo[w]=e</span><br><span class="line">                self.disTo[w]=e.weight</span><br><span class="line">                <span class="keyword">if</span> self.con_(self.pq,w):</span><br><span class="line">                    ss=self.find_(self.pq,w)</span><br><span class="line">                    self.pq[ss][<span class="number">1</span>]=self.disTo[w]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.pq.append((w,self.disTo[w]))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">con_</span>(<span class="params">self,pq,w</span>):</span></span><br><span class="line">        site=[]</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> pq:</span><br><span class="line">            site.append(p[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span>  w <span class="keyword">in</span> site</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_</span>(<span class="params">self,pq,w</span>):</span></span><br><span class="line">        site=[]</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> pq:</span><br><span class="line">            site.append(p[<span class="number">0</span>])</span><br><span class="line">        i=site.index(w)</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line"><span class="comment">#测试程序</span></span><br><span class="line">Pr=PrimMST(EWG)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_path</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(Pr.edgeTo[x].toString())</span><br><span class="line">    <span class="keyword">if</span> x!=<span class="number">0</span>:</span><br><span class="line">        x=Pr.edgeTo[x].order(x)</span><br><span class="line">        get_path(x)</span><br><span class="line"></span><br><span class="line">get_path(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#输出结果</span></span><br><span class="line"><span class="comment"># 2-3 5.00</span></span><br><span class="line"><span class="comment"># 4-2 3.00</span></span><br><span class="line"><span class="comment"># 1-4 7.00</span></span><br><span class="line"><span class="comment"># 0-1 2.00</span></span><br><span class="line"><span class="comment"># 0-0 0.00</span></span><br></pre></td></tr></table></figure>
<p>#kruskal算法，这个的思路是找最短的边先加入表中，形成环的不要，以此类推，找到最小生成树<br>#要用到union_find算法<br>#这个算法要前面的知识，我是跳着读的，现在太晚了，暂时先不研究了</p>
<p>最短路径留在下次吧<br>2022年2月5日02:39:11</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://fengbinlin.github.io/myblog.github.io/2022/02/03/%E5%9B%BE%E6%96%B9%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0/" data-id="ckzcsxehn000l0cuiezp1abut" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/myblog.github.io/2022/02/05/2022-2-5/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          2022-2-5
        
      </div>
    </a>
  
  
    <a href="/myblog.github.io/2022/02/03/2022-2-3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">2022-2-3</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/myblog.github.io/archives/2022/02/">February 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/myblog.github.io/archives/2022/01/">January 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/myblog.github.io/2022/02/07/2022-2-7-%E4%BF%AE%E8%A1%8C/">2022-2-7-修行</a>
          </li>
        
          <li>
            <a href="/myblog.github.io/2022/02/06/%E6%83%B3%E6%88%90%E4%B8%BA%E6%B8%B8%E6%88%8F%E5%AF%BC%E6%BC%94%EF%BC%8C%E4%B8%BA%E8%BF%99%E4%B8%AA%E4%B8%96%E7%95%8C%E5%B8%A6%E6%9D%A5%E5%A5%87%E5%A6%99%E7%9A%84%E2%80%9C%E9%AD%94%E6%B3%95%E2%80%9D/">想成为游戏导演，为这个世界带来奇妙的“魔法”</a>
          </li>
        
          <li>
            <a href="/myblog.github.io/2022/02/06/2022-2-6-%E4%BF%AE%E8%A1%8C/">2022-2-6-修行</a>
          </li>
        
          <li>
            <a href="/myblog.github.io/2022/02/05/2022-2-5/">2022-2-5</a>
          </li>
        
          <li>
            <a href="/myblog.github.io/2022/02/03/%E5%9B%BE%E6%96%B9%E6%B3%95%E7%9A%84python%E5%AE%9E%E7%8E%B0/">图方法的python实现</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/myblog.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/myblog.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/myblog.github.io/fancybox/jquery.fancybox.css">

  
<script src="/myblog.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/myblog.github.io/js/script.js"></script>




  </div>
</body>
</html>